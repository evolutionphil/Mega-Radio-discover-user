1) Add a small UI lock + a single scheduler for setDisplayArea()

Put these new fields and helpers at the top of the object:

ui_lock_until: 0,
display_area_timeout: null,

lockUI(ms = 700) { this.ui_lock_until = Date.now() + ms; },
uiLocked() { return Date.now() < this.ui_lock_until; },

scheduleSetDisplayArea(cb, delay = 250) {
  if (this.display_area_timeout) clearTimeout(this.display_area_timeout);
  this.display_area_timeout = setTimeout(() => {
    this.display_area_timeout = null;
    try { cb && cb(); } catch (e) { console.log('setDisplayArea error:', e); }
  }, delay);
},

2) Ensure clicks don’t bubble into key/OK handlers

Change the generated HTML so the click handler receives the event and stops it:

- onclick="channel_page.channelItemClick('+index+')"
+ onclick="channel_page.channelItemClick('+index+', event)"


And update the function signature:

- channelItemClick:function(index){
+ channelItemClick:function(index, evt){
+   if (evt) { evt.preventDefault(); evt.stopPropagation(); }

3) When zooming IN on the same channel: set focus early, lock UI, and use the scheduler

Inside channelItemClick for SAME CHANNEL (where you currently set transitioning_to_fullscreen and call zoomInOut()), tighten it up:

if(this.current_channel_id==stream_id){
  console.log('channelItemClick: SAME CHANNEL - checking if should zoom');
  if(!this.full_screen_video){
    console.log('channelItemClick: Not fullscreen - ZOOMING IN');
-   this.full_screen_video=true;
-   this.transitioning_to_fullscreen=true;
-   var that=this;
-   setTimeout(function(){
-       console.log('channelItemClick: Clearing transitioning_to_fullscreen flag after 800ms');
-       that.transitioning_to_fullscreen=false;
-   }, 800);
-   this.zoomInOut();
+   this.keys.focused_part = "full_screen";      // focus intent immediately
+   this.full_screen_video = true;
+   this.transitioning_to_fullscreen = true;
+   this.lockUI(800);                             // ignore late ENTERs
+   this.zoomInOut();                             // will clear transition
  } else {
    console.log('channelItemClick: Already fullscreen - doing nothing');
  }
}

4) Make zoomInOut() use the single scheduler, and clear transitioning_to_fullscreen there

Replace both raw setTimeout(... media_player.setDisplayArea ...) calls with scheduleSetDisplayArea. Also finish the transition here:

if(!this.full_screen_video){
  // ... preview mode CSS etc.
  this.keys.focused_part="channel_selection";
  media_player.full_screen_state=0;
- setTimeout(function () { media_player.setDisplayArea(); }, 250);
+ this.scheduleSetDisplayArea(() => media_player.setDisplayArea(), 250);
  // ... UI hides/shows
+ this.transitioning_to_fullscreen = false;  // ensure cleared on any direction
} else {
  // ... fullscreen CSS etc.
  media_player.full_screen_state=1;
- setTimeout(function () {
-   console.log('zoomInOut() ZOOM IN setTimeout firing - calling setDisplayArea()');
-   media_player.setDisplayArea();
- }, 250);
+ this.scheduleSetDisplayArea(() => {
+   console.log('zoomInOut() ZOOM IN: setDisplayArea()');
+   media_player.setDisplayArea();
+ }, 250);
  // ... UI shows
  this.full_screen_timer=setTimeout(function(){
    $('#full-screen-information').removeClass('visible');
    $('#full-screen-channel-name').fadeOut(400);
  },5000)
  this.keys.focused_part="full_screen";
+ this.transitioning_to_fullscreen = false;  // clear after applying rect
}

5) Stop preview setDisplayArea() from racing with fullscreen

In showLiveChannelMovie, you schedule a preview setDisplayArea() when not fullscreen. Route that through the same scheduler so a subsequent zoom-in can cancel it:

if(media_player.full_screen_state !== 1){
  console.log('showLiveChannelMovie: full_screen_state !== 1, scheduling setDisplayArea() for preview mode');
- setTimeout(function(){
-   try{ media_player.setDisplayArea(); }catch(e){ console.log(e); }
- }, 250);
+ this.scheduleSetDisplayArea(() => media_player.setDisplayArea(), 250);
}

6) Don’t exit fullscreen on ENTER; show OSD instead (and respect locks)

Your own comment in handleMenuClick says ENTER in fullscreen should show info. Do that—don’t exit. Also add the UI lock guard up front.

handleMenuClick:function(){
  console.log('...');

+ if (this.uiLocked()) {
+   console.log('handleMenuClick: blocked by ui lock');
+   return;
+ }

  if(this.transitioning_to_fullscreen){
    console.log('handleMenuClick: *** BLOCKED BY DEBOUNCE FLAG ***');
    return;
  }

  var keys=this.keys;
  if(keys.focused_part==="search_back_selection"){
    // ...
    return;
  }
  if(keys.focused_part==="channel_selection"){
    $(this.menu_items[keys.channel_selection]).trigger('click');
    return;
  }
  if(keys.focused_part==="full_screen"){
-   if(this.transitioning_to_fullscreen){
-     console.log('handleMenuClick: Ignoring OK press - transition in progress');
-     return;
-   }
-   console.log('handleMenuClick: Exiting fullscreen');
-   this.keys.focused_part="channel_selection";
-   this.full_screen_video=false;
-   this.zoomInOut();
-   return;
+   // ENTER in fullscreen => show OSD, do NOT exit
+   if (this.transitioning_to_fullscreen) return;
+   clearTimeout(this.full_screen_timer);
+   $('#full-screen-information').addClass('visible');
+   $('#full-screen-channel-name').stop(true, true).slideDown(200);
+   this.full_screen_timer = setTimeout(() => {
+     $('#full-screen-information').removeClass('visible');
+     $('#full-screen-channel-name').slideUp(400);
+   }, 5000);
+   return;
  }
  // ...
}


You can still exit fullscreen via your existing goBack() (RETURN) or map another key (e.g., tvKey.MENU) to call the zoom-out block you removed above.

7) Optional: make zoom-out also lock briefly

If you ever zoom out programmatically, lock for ~400–700ms so a stale ENTER can’t flip you back.

if(!this.full_screen_video){
  // ZOOM OUT branch
  this.keys.focused_part="channel_selection";
  media_player.full_screen_state=0;
+ this.lockUI(400);
  // ...
}

Why this fixes the flicker

Single scheduler: only the latest setDisplayArea() fires, so preview/fullscreen calls can’t stomp each other.

UI lock + early focus: we ignore any late ENTER/OK that lands right after zoom-in begins.

ENTER behavior corrected: in fullscreen, ENTER shows the OSD instead of toggling out—so one action doesn’t immediately undo the other.

If you want, paste back your updated handleMenuClick and zoomInOut after applying this; I’ll sanity-check the flow and edge cases (channel change while transitioning, rapid double-clicks, etc.).